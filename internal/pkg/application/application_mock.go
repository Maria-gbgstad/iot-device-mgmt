// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package application

import (
	"context"
	"github.com/diwise/iot-device-mgmt/pkg/types"
	"sync"
)

// Ensure, that AppMock does implement App.
// If this is not the case, regenerate this file with moq.
var _ App = &AppMock{}

// AppMock is a mock implementation of App.
//
// 	func TestSomethingThatUsesApp(t *testing.T) {
//
// 		// make and configure a mocked App
// 		mockedApp := &AppMock{
// 			CreateDeviceFunc: func(ctx context.Context, device types.Device) error {
// 				panic("mock out the CreateDevice method")
// 			},
// 			GetDeviceFunc: func(ctx context.Context, deviceID string) (types.Device, error) {
// 				panic("mock out the GetDevice method")
// 			},
// 			GetDeviceByEUIFunc: func(ctx context.Context, eui string) (types.Device, error) {
// 				panic("mock out the GetDeviceByEUI method")
// 			},
// 			GetDevicesFunc: func(ctx context.Context, tenants []string) ([]types.Device, error) {
// 				panic("mock out the GetDevices method")
// 			},
// 			GetEnvironmentsFunc: func(ctx context.Context) ([]types.Environment, error) {
// 				panic("mock out the GetEnvironments method")
// 			},
// 			GetTenantsFunc: func(ctx context.Context) ([]string, error) {
// 				panic("mock out the GetTenants method")
// 			},
// 			HandleFunc: func(ctx context.Context, ds types.DeviceStatus) error {
// 				panic("mock out the Handle method")
// 			},
// 			HandleFeatureFunc: func(ctx context.Context, feat []byte) error {
// 				panic("mock out the HandleFeature method")
// 			},
// 			SetStatusFunc: func(ctx context.Context, deviceID string, message types.DeviceStatus) error {
// 				panic("mock out the SetStatus method")
// 			},
// 			StartFunc: func()  {
// 				panic("mock out the Start method")
// 			},
// 			StopFunc: func()  {
// 				panic("mock out the Stop method")
// 			},
// 			UpdateDeviceFunc: func(ctx context.Context, deviceID string, fields map[string]interface{}) (types.Device, error) {
// 				panic("mock out the UpdateDevice method")
// 			},
// 		}
//
// 		// use mockedApp in code that requires App
// 		// and then make assertions.
//
// 	}
type AppMock struct {
	// CreateDeviceFunc mocks the CreateDevice method.
	CreateDeviceFunc func(ctx context.Context, device types.Device) error

	// GetDeviceFunc mocks the GetDevice method.
	GetDeviceFunc func(ctx context.Context, deviceID string) (types.Device, error)

	// GetDeviceByEUIFunc mocks the GetDeviceByEUI method.
	GetDeviceByEUIFunc func(ctx context.Context, eui string) (types.Device, error)

	// GetDevicesFunc mocks the GetDevices method.
	GetDevicesFunc func(ctx context.Context, tenants []string) ([]types.Device, error)

	// GetEnvironmentsFunc mocks the GetEnvironments method.
	GetEnvironmentsFunc func(ctx context.Context) ([]types.Environment, error)

	// GetTenantsFunc mocks the GetTenants method.
	GetTenantsFunc func(ctx context.Context) ([]string, error)

	// HandleFunc mocks the Handle method.
	HandleFunc func(ctx context.Context, ds types.DeviceStatus) error

	// HandleFeatureFunc mocks the HandleFeature method.
	HandleFeatureFunc func(ctx context.Context, feat []byte) error

	// SetStatusFunc mocks the SetStatus method.
	SetStatusFunc func(ctx context.Context, deviceID string, message types.DeviceStatus) error

	// StartFunc mocks the Start method.
	StartFunc func()

	// StopFunc mocks the Stop method.
	StopFunc func()

	// UpdateDeviceFunc mocks the UpdateDevice method.
	UpdateDeviceFunc func(ctx context.Context, deviceID string, fields map[string]interface{}) (types.Device, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateDevice holds details about calls to the CreateDevice method.
		CreateDevice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Device is the device argument value.
			Device types.Device
		}
		// GetDevice holds details about calls to the GetDevice method.
		GetDevice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
		}
		// GetDeviceByEUI holds details about calls to the GetDeviceByEUI method.
		GetDeviceByEUI []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Eui is the eui argument value.
			Eui string
		}
		// GetDevices holds details about calls to the GetDevices method.
		GetDevices []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// GetEnvironments holds details about calls to the GetEnvironments method.
		GetEnvironments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetTenants holds details about calls to the GetTenants method.
		GetTenants []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Handle holds details about calls to the Handle method.
		Handle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ds is the ds argument value.
			Ds types.DeviceStatus
		}
		// HandleFeature holds details about calls to the HandleFeature method.
		HandleFeature []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Feat is the feat argument value.
			Feat []byte
		}
		// SetStatus holds details about calls to the SetStatus method.
		SetStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Message is the message argument value.
			Message types.DeviceStatus
		}
		// Start holds details about calls to the Start method.
		Start []struct {
		}
		// Stop holds details about calls to the Stop method.
		Stop []struct {
		}
		// UpdateDevice holds details about calls to the UpdateDevice method.
		UpdateDevice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Fields is the fields argument value.
			Fields map[string]interface{}
		}
	}
	lockCreateDevice    sync.RWMutex
	lockGetDevice       sync.RWMutex
	lockGetDeviceByEUI  sync.RWMutex
	lockGetDevices      sync.RWMutex
	lockGetEnvironments sync.RWMutex
	lockGetTenants      sync.RWMutex
	lockHandle          sync.RWMutex
	lockHandleFeature   sync.RWMutex
	lockSetStatus       sync.RWMutex
	lockStart           sync.RWMutex
	lockStop            sync.RWMutex
	lockUpdateDevice    sync.RWMutex
}

// CreateDevice calls CreateDeviceFunc.
func (mock *AppMock) CreateDevice(ctx context.Context, device types.Device) error {
	if mock.CreateDeviceFunc == nil {
		panic("AppMock.CreateDeviceFunc: method is nil but App.CreateDevice was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Device types.Device
	}{
		Ctx:    ctx,
		Device: device,
	}
	mock.lockCreateDevice.Lock()
	mock.calls.CreateDevice = append(mock.calls.CreateDevice, callInfo)
	mock.lockCreateDevice.Unlock()
	return mock.CreateDeviceFunc(ctx, device)
}

// CreateDeviceCalls gets all the calls that were made to CreateDevice.
// Check the length with:
//     len(mockedApp.CreateDeviceCalls())
func (mock *AppMock) CreateDeviceCalls() []struct {
	Ctx    context.Context
	Device types.Device
} {
	var calls []struct {
		Ctx    context.Context
		Device types.Device
	}
	mock.lockCreateDevice.RLock()
	calls = mock.calls.CreateDevice
	mock.lockCreateDevice.RUnlock()
	return calls
}

// GetDevice calls GetDeviceFunc.
func (mock *AppMock) GetDevice(ctx context.Context, deviceID string) (types.Device, error) {
	if mock.GetDeviceFunc == nil {
		panic("AppMock.GetDeviceFunc: method is nil but App.GetDevice was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
	}
	mock.lockGetDevice.Lock()
	mock.calls.GetDevice = append(mock.calls.GetDevice, callInfo)
	mock.lockGetDevice.Unlock()
	return mock.GetDeviceFunc(ctx, deviceID)
}

// GetDeviceCalls gets all the calls that were made to GetDevice.
// Check the length with:
//     len(mockedApp.GetDeviceCalls())
func (mock *AppMock) GetDeviceCalls() []struct {
	Ctx      context.Context
	DeviceID string
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
	}
	mock.lockGetDevice.RLock()
	calls = mock.calls.GetDevice
	mock.lockGetDevice.RUnlock()
	return calls
}

// GetDeviceByEUI calls GetDeviceByEUIFunc.
func (mock *AppMock) GetDeviceByEUI(ctx context.Context, eui string) (types.Device, error) {
	if mock.GetDeviceByEUIFunc == nil {
		panic("AppMock.GetDeviceByEUIFunc: method is nil but App.GetDeviceByEUI was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Eui string
	}{
		Ctx: ctx,
		Eui: eui,
	}
	mock.lockGetDeviceByEUI.Lock()
	mock.calls.GetDeviceByEUI = append(mock.calls.GetDeviceByEUI, callInfo)
	mock.lockGetDeviceByEUI.Unlock()
	return mock.GetDeviceByEUIFunc(ctx, eui)
}

// GetDeviceByEUICalls gets all the calls that were made to GetDeviceByEUI.
// Check the length with:
//     len(mockedApp.GetDeviceByEUICalls())
func (mock *AppMock) GetDeviceByEUICalls() []struct {
	Ctx context.Context
	Eui string
} {
	var calls []struct {
		Ctx context.Context
		Eui string
	}
	mock.lockGetDeviceByEUI.RLock()
	calls = mock.calls.GetDeviceByEUI
	mock.lockGetDeviceByEUI.RUnlock()
	return calls
}

// GetDevices calls GetDevicesFunc.
func (mock *AppMock) GetDevices(ctx context.Context, tenants []string) ([]types.Device, error) {
	if mock.GetDevicesFunc == nil {
		panic("AppMock.GetDevicesFunc: method is nil but App.GetDevices was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Tenants []string
	}{
		Ctx:     ctx,
		Tenants: tenants,
	}
	mock.lockGetDevices.Lock()
	mock.calls.GetDevices = append(mock.calls.GetDevices, callInfo)
	mock.lockGetDevices.Unlock()
	return mock.GetDevicesFunc(ctx, tenants)
}

// GetDevicesCalls gets all the calls that were made to GetDevices.
// Check the length with:
//     len(mockedApp.GetDevicesCalls())
func (mock *AppMock) GetDevicesCalls() []struct {
	Ctx     context.Context
	Tenants []string
} {
	var calls []struct {
		Ctx     context.Context
		Tenants []string
	}
	mock.lockGetDevices.RLock()
	calls = mock.calls.GetDevices
	mock.lockGetDevices.RUnlock()
	return calls
}

// GetEnvironments calls GetEnvironmentsFunc.
func (mock *AppMock) GetEnvironments(ctx context.Context) ([]types.Environment, error) {
	if mock.GetEnvironmentsFunc == nil {
		panic("AppMock.GetEnvironmentsFunc: method is nil but App.GetEnvironments was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetEnvironments.Lock()
	mock.calls.GetEnvironments = append(mock.calls.GetEnvironments, callInfo)
	mock.lockGetEnvironments.Unlock()
	return mock.GetEnvironmentsFunc(ctx)
}

// GetEnvironmentsCalls gets all the calls that were made to GetEnvironments.
// Check the length with:
//     len(mockedApp.GetEnvironmentsCalls())
func (mock *AppMock) GetEnvironmentsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetEnvironments.RLock()
	calls = mock.calls.GetEnvironments
	mock.lockGetEnvironments.RUnlock()
	return calls
}

// GetTenants calls GetTenantsFunc.
func (mock *AppMock) GetTenants(ctx context.Context) ([]string, error) {
	if mock.GetTenantsFunc == nil {
		panic("AppMock.GetTenantsFunc: method is nil but App.GetTenants was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTenants.Lock()
	mock.calls.GetTenants = append(mock.calls.GetTenants, callInfo)
	mock.lockGetTenants.Unlock()
	return mock.GetTenantsFunc(ctx)
}

// GetTenantsCalls gets all the calls that were made to GetTenants.
// Check the length with:
//     len(mockedApp.GetTenantsCalls())
func (mock *AppMock) GetTenantsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetTenants.RLock()
	calls = mock.calls.GetTenants
	mock.lockGetTenants.RUnlock()
	return calls
}

// Handle calls HandleFunc.
func (mock *AppMock) Handle(ctx context.Context, ds types.DeviceStatus) error {
	if mock.HandleFunc == nil {
		panic("AppMock.HandleFunc: method is nil but App.Handle was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ds  types.DeviceStatus
	}{
		Ctx: ctx,
		Ds:  ds,
	}
	mock.lockHandle.Lock()
	mock.calls.Handle = append(mock.calls.Handle, callInfo)
	mock.lockHandle.Unlock()
	return mock.HandleFunc(ctx, ds)
}

// HandleCalls gets all the calls that were made to Handle.
// Check the length with:
//     len(mockedApp.HandleCalls())
func (mock *AppMock) HandleCalls() []struct {
	Ctx context.Context
	Ds  types.DeviceStatus
} {
	var calls []struct {
		Ctx context.Context
		Ds  types.DeviceStatus
	}
	mock.lockHandle.RLock()
	calls = mock.calls.Handle
	mock.lockHandle.RUnlock()
	return calls
}

// HandleFeature calls HandleFeatureFunc.
func (mock *AppMock) HandleFeature(ctx context.Context, feat []byte) error {
	if mock.HandleFeatureFunc == nil {
		panic("AppMock.HandleFeatureFunc: method is nil but App.HandleFeature was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Feat []byte
	}{
		Ctx:  ctx,
		Feat: feat,
	}
	mock.lockHandleFeature.Lock()
	mock.calls.HandleFeature = append(mock.calls.HandleFeature, callInfo)
	mock.lockHandleFeature.Unlock()
	return mock.HandleFeatureFunc(ctx, feat)
}

// HandleFeatureCalls gets all the calls that were made to HandleFeature.
// Check the length with:
//     len(mockedApp.HandleFeatureCalls())
func (mock *AppMock) HandleFeatureCalls() []struct {
	Ctx  context.Context
	Feat []byte
} {
	var calls []struct {
		Ctx  context.Context
		Feat []byte
	}
	mock.lockHandleFeature.RLock()
	calls = mock.calls.HandleFeature
	mock.lockHandleFeature.RUnlock()
	return calls
}

// SetStatus calls SetStatusFunc.
func (mock *AppMock) SetStatus(ctx context.Context, deviceID string, message types.DeviceStatus) error {
	if mock.SetStatusFunc == nil {
		panic("AppMock.SetStatusFunc: method is nil but App.SetStatus was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
		Message  types.DeviceStatus
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
		Message:  message,
	}
	mock.lockSetStatus.Lock()
	mock.calls.SetStatus = append(mock.calls.SetStatus, callInfo)
	mock.lockSetStatus.Unlock()
	return mock.SetStatusFunc(ctx, deviceID, message)
}

// SetStatusCalls gets all the calls that were made to SetStatus.
// Check the length with:
//     len(mockedApp.SetStatusCalls())
func (mock *AppMock) SetStatusCalls() []struct {
	Ctx      context.Context
	DeviceID string
	Message  types.DeviceStatus
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
		Message  types.DeviceStatus
	}
	mock.lockSetStatus.RLock()
	calls = mock.calls.SetStatus
	mock.lockSetStatus.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *AppMock) Start() {
	if mock.StartFunc == nil {
		panic("AppMock.StartFunc: method is nil but App.Start was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	mock.StartFunc()
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//     len(mockedApp.StartCalls())
func (mock *AppMock) StartCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Stop calls StopFunc.
func (mock *AppMock) Stop() {
	if mock.StopFunc == nil {
		panic("AppMock.StopFunc: method is nil but App.Stop was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStop.Lock()
	mock.calls.Stop = append(mock.calls.Stop, callInfo)
	mock.lockStop.Unlock()
	mock.StopFunc()
}

// StopCalls gets all the calls that were made to Stop.
// Check the length with:
//     len(mockedApp.StopCalls())
func (mock *AppMock) StopCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStop.RLock()
	calls = mock.calls.Stop
	mock.lockStop.RUnlock()
	return calls
}

// UpdateDevice calls UpdateDeviceFunc.
func (mock *AppMock) UpdateDevice(ctx context.Context, deviceID string, fields map[string]interface{}) (types.Device, error) {
	if mock.UpdateDeviceFunc == nil {
		panic("AppMock.UpdateDeviceFunc: method is nil but App.UpdateDevice was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
		Fields   map[string]interface{}
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
		Fields:   fields,
	}
	mock.lockUpdateDevice.Lock()
	mock.calls.UpdateDevice = append(mock.calls.UpdateDevice, callInfo)
	mock.lockUpdateDevice.Unlock()
	return mock.UpdateDeviceFunc(ctx, deviceID, fields)
}

// UpdateDeviceCalls gets all the calls that were made to UpdateDevice.
// Check the length with:
//     len(mockedApp.UpdateDeviceCalls())
func (mock *AppMock) UpdateDeviceCalls() []struct {
	Ctx      context.Context
	DeviceID string
	Fields   map[string]interface{}
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
		Fields   map[string]interface{}
	}
	mock.lockUpdateDevice.RLock()
	calls = mock.calls.UpdateDevice
	mock.lockUpdateDevice.RUnlock()
	return calls
}
