// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package alarms

import (
	"context"
	"github.com/diwise/iot-device-mgmt/internal/pkg/infrastructure/storage"
	"github.com/diwise/iot-device-mgmt/pkg/types"
	"sync"
)

// Ensure, that AlarmRepositoryMock does implement AlarmRepository.
// If this is not the case, regenerate this file with moq.
var _ AlarmRepository = &AlarmRepositoryMock{}

// AlarmRepositoryMock is a mock implementation of AlarmRepository.
//
//	func TestSomethingThatUsesAlarmRepository(t *testing.T) {
//
//		// make and configure a mocked AlarmRepository
//		mockedAlarmRepository := &AlarmRepositoryMock{
//			AddAlarmFunc: func(ctx context.Context, alarm types.Alarm, tenant string) error {
//				panic("mock out the AddAlarm method")
//			},
//			CloseAlarmFunc: func(ctx context.Context, alarmID string, tenant string) error {
//				panic("mock out the CloseAlarm method")
//			},
//			GetAlarmFunc: func(ctx context.Context, conditions ...storage.ConditionFunc) (types.Alarm, error) {
//				panic("mock out the GetAlarm method")
//			},
//			QueryAlarmsFunc: func(ctx context.Context, conditions ...storage.ConditionFunc) (types.Collection[types.Alarm], error) {
//				panic("mock out the QueryAlarms method")
//			},
//		}
//
//		// use mockedAlarmRepository in code that requires AlarmRepository
//		// and then make assertions.
//
//	}
type AlarmRepositoryMock struct {
	// AddAlarmFunc mocks the AddAlarm method.
	AddAlarmFunc func(ctx context.Context, alarm types.Alarm, tenant string) error

	// CloseAlarmFunc mocks the CloseAlarm method.
	CloseAlarmFunc func(ctx context.Context, alarmID string, tenant string) error

	// GetAlarmFunc mocks the GetAlarm method.
	GetAlarmFunc func(ctx context.Context, conditions ...storage.ConditionFunc) (types.Alarm, error)

	// QueryAlarmsFunc mocks the QueryAlarms method.
	QueryAlarmsFunc func(ctx context.Context, conditions ...storage.ConditionFunc) (types.Collection[types.Alarm], error)

	// calls tracks calls to the methods.
	calls struct {
		// AddAlarm holds details about calls to the AddAlarm method.
		AddAlarm []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Alarm is the alarm argument value.
			Alarm types.Alarm
			// Tenant is the tenant argument value.
			Tenant string
		}
		// CloseAlarm holds details about calls to the CloseAlarm method.
		CloseAlarm []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlarmID is the alarmID argument value.
			AlarmID string
			// Tenant is the tenant argument value.
			Tenant string
		}
		// GetAlarm holds details about calls to the GetAlarm method.
		GetAlarm []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Conditions is the conditions argument value.
			Conditions []storage.ConditionFunc
		}
		// QueryAlarms holds details about calls to the QueryAlarms method.
		QueryAlarms []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Conditions is the conditions argument value.
			Conditions []storage.ConditionFunc
		}
	}
	lockAddAlarm    sync.RWMutex
	lockCloseAlarm  sync.RWMutex
	lockGetAlarm    sync.RWMutex
	lockQueryAlarms sync.RWMutex
}

// AddAlarm calls AddAlarmFunc.
func (mock *AlarmRepositoryMock) AddAlarm(ctx context.Context, alarm types.Alarm, tenant string) error {
	if mock.AddAlarmFunc == nil {
		panic("AlarmRepositoryMock.AddAlarmFunc: method is nil but AlarmRepository.AddAlarm was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Alarm  types.Alarm
		Tenant string
	}{
		Ctx:    ctx,
		Alarm:  alarm,
		Tenant: tenant,
	}
	mock.lockAddAlarm.Lock()
	mock.calls.AddAlarm = append(mock.calls.AddAlarm, callInfo)
	mock.lockAddAlarm.Unlock()
	return mock.AddAlarmFunc(ctx, alarm, tenant)
}

// AddAlarmCalls gets all the calls that were made to AddAlarm.
// Check the length with:
//
//	len(mockedAlarmRepository.AddAlarmCalls())
func (mock *AlarmRepositoryMock) AddAlarmCalls() []struct {
	Ctx    context.Context
	Alarm  types.Alarm
	Tenant string
} {
	var calls []struct {
		Ctx    context.Context
		Alarm  types.Alarm
		Tenant string
	}
	mock.lockAddAlarm.RLock()
	calls = mock.calls.AddAlarm
	mock.lockAddAlarm.RUnlock()
	return calls
}

// CloseAlarm calls CloseAlarmFunc.
func (mock *AlarmRepositoryMock) CloseAlarm(ctx context.Context, alarmID string, tenant string) error {
	if mock.CloseAlarmFunc == nil {
		panic("AlarmRepositoryMock.CloseAlarmFunc: method is nil but AlarmRepository.CloseAlarm was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		AlarmID string
		Tenant  string
	}{
		Ctx:     ctx,
		AlarmID: alarmID,
		Tenant:  tenant,
	}
	mock.lockCloseAlarm.Lock()
	mock.calls.CloseAlarm = append(mock.calls.CloseAlarm, callInfo)
	mock.lockCloseAlarm.Unlock()
	return mock.CloseAlarmFunc(ctx, alarmID, tenant)
}

// CloseAlarmCalls gets all the calls that were made to CloseAlarm.
// Check the length with:
//
//	len(mockedAlarmRepository.CloseAlarmCalls())
func (mock *AlarmRepositoryMock) CloseAlarmCalls() []struct {
	Ctx     context.Context
	AlarmID string
	Tenant  string
} {
	var calls []struct {
		Ctx     context.Context
		AlarmID string
		Tenant  string
	}
	mock.lockCloseAlarm.RLock()
	calls = mock.calls.CloseAlarm
	mock.lockCloseAlarm.RUnlock()
	return calls
}

// GetAlarm calls GetAlarmFunc.
func (mock *AlarmRepositoryMock) GetAlarm(ctx context.Context, conditions ...storage.ConditionFunc) (types.Alarm, error) {
	if mock.GetAlarmFunc == nil {
		panic("AlarmRepositoryMock.GetAlarmFunc: method is nil but AlarmRepository.GetAlarm was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Conditions []storage.ConditionFunc
	}{
		Ctx:        ctx,
		Conditions: conditions,
	}
	mock.lockGetAlarm.Lock()
	mock.calls.GetAlarm = append(mock.calls.GetAlarm, callInfo)
	mock.lockGetAlarm.Unlock()
	return mock.GetAlarmFunc(ctx, conditions...)
}

// GetAlarmCalls gets all the calls that were made to GetAlarm.
// Check the length with:
//
//	len(mockedAlarmRepository.GetAlarmCalls())
func (mock *AlarmRepositoryMock) GetAlarmCalls() []struct {
	Ctx        context.Context
	Conditions []storage.ConditionFunc
} {
	var calls []struct {
		Ctx        context.Context
		Conditions []storage.ConditionFunc
	}
	mock.lockGetAlarm.RLock()
	calls = mock.calls.GetAlarm
	mock.lockGetAlarm.RUnlock()
	return calls
}

// QueryAlarms calls QueryAlarmsFunc.
func (mock *AlarmRepositoryMock) QueryAlarms(ctx context.Context, conditions ...storage.ConditionFunc) (types.Collection[types.Alarm], error) {
	if mock.QueryAlarmsFunc == nil {
		panic("AlarmRepositoryMock.QueryAlarmsFunc: method is nil but AlarmRepository.QueryAlarms was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Conditions []storage.ConditionFunc
	}{
		Ctx:        ctx,
		Conditions: conditions,
	}
	mock.lockQueryAlarms.Lock()
	mock.calls.QueryAlarms = append(mock.calls.QueryAlarms, callInfo)
	mock.lockQueryAlarms.Unlock()
	return mock.QueryAlarmsFunc(ctx, conditions...)
}

// QueryAlarmsCalls gets all the calls that were made to QueryAlarms.
// Check the length with:
//
//	len(mockedAlarmRepository.QueryAlarmsCalls())
func (mock *AlarmRepositoryMock) QueryAlarmsCalls() []struct {
	Ctx        context.Context
	Conditions []storage.ConditionFunc
} {
	var calls []struct {
		Ctx        context.Context
		Conditions []storage.ConditionFunc
	}
	mock.lockQueryAlarms.RLock()
	calls = mock.calls.QueryAlarms
	mock.lockQueryAlarms.RUnlock()
	return calls
}
