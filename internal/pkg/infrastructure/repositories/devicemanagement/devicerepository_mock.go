// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package devicemanagement

import (
	"context"
	types "github.com/diwise/iot-device-mgmt/internal/pkg/infrastructure/repositories"
	models "github.com/diwise/iot-device-mgmt/pkg/types"
	"sync"
)

// Ensure, that DeviceRepositoryMock does implement DeviceRepository.
// If this is not the case, regenerate this file with moq.
var _ DeviceRepository = &DeviceRepositoryMock{}

// DeviceRepositoryMock is a mock implementation of DeviceRepository.
//
// 	func TestSomethingThatUsesDeviceRepository(t *testing.T) {
//
// 		// make and configure a mocked DeviceRepository
// 		mockedDeviceRepository := &DeviceRepositoryMock{
// 			GetFunc: func(ctx context.Context, offset int, limit int, q string, sortBy string, tenants []string) (types.Collection[Device], error) {
// 				panic("mock out the Get method")
// 			},
// 			GetByDeviceIDFunc: func(ctx context.Context, deviceID string, tenants []string) (models.Device, error) {
// 				panic("mock out the GetByDeviceID method")
// 			},
// 			GetBySensorIDFunc: func(ctx context.Context, sensorID string, tenants []string) (models.Device, error) {
// 				panic("mock out the GetBySensorID method")
// 			},
// 			GetOnlineDevicesFunc: func(ctx context.Context, offset int, limit int, sortBy string, tenants []string) (types.Collection[Device], error) {
// 				panic("mock out the GetOnlineDevices method")
// 			},
// 			GetTenantsFunc: func(ctx context.Context) []string {
// 				panic("mock out the GetTenants method")
// 			},
// 			GetWithAlarmIDFunc: func(ctx context.Context, alarmID string, tenants []string) (models.Device, error) {
// 				panic("mock out the GetWithAlarmID method")
// 			},
// 			GetWithinBoundsFunc: func(ctx context.Context, bounds types.Bounds) (types.Collection[Device], error) {
// 				panic("mock out the GetWithinBounds method")
// 			},
// 			SaveFunc: func(ctx context.Context, device models.Device) error {
// 				panic("mock out the Save method")
// 			},
// 			UpdateStateFunc: func(ctx context.Context, deviceID string, tenant string, deviceState models.DeviceState) error {
// 				panic("mock out the UpdateState method")
// 			},
// 			UpdateStatusFunc: func(ctx context.Context, deviceID string, tenant string, deviceStatus models.DeviceStatus) error {
// 				panic("mock out the UpdateStatus method")
// 			},
// 		}
//
// 		// use mockedDeviceRepository in code that requires DeviceRepository
// 		// and then make assertions.
//
// 	}
type DeviceRepositoryMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, offset int, limit int, q string, sortBy string, tenants []string) (types.Collection[models.Device], error)

	// GetByDeviceIDFunc mocks the GetByDeviceID method.
	GetByDeviceIDFunc func(ctx context.Context, deviceID string, tenants []string) (models.Device, error)

	// GetBySensorIDFunc mocks the GetBySensorID method.
	GetBySensorIDFunc func(ctx context.Context, sensorID string, tenants []string) (models.Device, error)

	// GetOnlineDevicesFunc mocks the GetOnlineDevices method.
	GetOnlineDevicesFunc func(ctx context.Context, offset int, limit int, sortBy string, tenants []string) (types.Collection[models.Device], error)

	// GetTenantsFunc mocks the GetTenants method.
	GetTenantsFunc func(ctx context.Context) []string

	// GetWithAlarmIDFunc mocks the GetWithAlarmID method.
	GetWithAlarmIDFunc func(ctx context.Context, alarmID string, tenants []string) (models.Device, error)

	// GetWithinBoundsFunc mocks the GetWithinBounds method.
	GetWithinBoundsFunc func(ctx context.Context, bounds types.Bounds) (types.Collection[models.Device], error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, device models.Device) error

	// UpdateStateFunc mocks the UpdateState method.
	UpdateStateFunc func(ctx context.Context, deviceID string, tenant string, deviceState models.DeviceState) error

	// UpdateStatusFunc mocks the UpdateStatus method.
	UpdateStatusFunc func(ctx context.Context, deviceID string, tenant string, deviceStatus models.DeviceStatus) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
			// Q is the q argument value.
			Q string
			// SortBy is the sortBy argument value.
			SortBy string
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// GetByDeviceID holds details about calls to the GetByDeviceID method.
		GetByDeviceID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// GetBySensorID holds details about calls to the GetBySensorID method.
		GetBySensorID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SensorID is the sensorID argument value.
			SensorID string
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// GetOnlineDevices holds details about calls to the GetOnlineDevices method.
		GetOnlineDevices []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
			// SortBy is the sortBy argument value.
			SortBy string
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// GetTenants holds details about calls to the GetTenants method.
		GetTenants []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetWithAlarmID holds details about calls to the GetWithAlarmID method.
		GetWithAlarmID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlarmID is the alarmID argument value.
			AlarmID string
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// GetWithinBounds holds details about calls to the GetWithinBounds method.
		GetWithinBounds []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Bounds is the bounds argument value.
			Bounds types.Bounds
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Device is the device argument value.
			Device models.Device
		}
		// UpdateState holds details about calls to the UpdateState method.
		UpdateState []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Tenant is the tenant argument value.
			Tenant string
			// DeviceState is the deviceState argument value.
			DeviceState models.DeviceState
		}
		// UpdateStatus holds details about calls to the UpdateStatus method.
		UpdateStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Tenant is the tenant argument value.
			Tenant string
			// DeviceStatus is the deviceStatus argument value.
			DeviceStatus models.DeviceStatus
		}
	}
	lockGet              sync.RWMutex
	lockGetByDeviceID    sync.RWMutex
	lockGetBySensorID    sync.RWMutex
	lockGetOnlineDevices sync.RWMutex
	lockGetTenants       sync.RWMutex
	lockGetWithAlarmID   sync.RWMutex
	lockGetWithinBounds  sync.RWMutex
	lockSave             sync.RWMutex
	lockUpdateState      sync.RWMutex
	lockUpdateStatus     sync.RWMutex
}

// Get calls GetFunc.
func (mock *DeviceRepositoryMock) Get(ctx context.Context, offset int, limit int, q string, sortBy string, tenants []string) (types.Collection[models.Device], error) {
	if mock.GetFunc == nil {
		panic("DeviceRepositoryMock.GetFunc: method is nil but DeviceRepository.Get was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Offset  int
		Limit   int
		Q       string
		SortBy  string
		Tenants []string
	}{
		Ctx:     ctx,
		Offset:  offset,
		Limit:   limit,
		Q:       q,
		SortBy:  sortBy,
		Tenants: tenants,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, offset, limit, q, sortBy, tenants)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedDeviceRepository.GetCalls())
func (mock *DeviceRepositoryMock) GetCalls() []struct {
	Ctx     context.Context
	Offset  int
	Limit   int
	Q       string
	SortBy  string
	Tenants []string
} {
	var calls []struct {
		Ctx     context.Context
		Offset  int
		Limit   int
		Q       string
		SortBy  string
		Tenants []string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetByDeviceID calls GetByDeviceIDFunc.
func (mock *DeviceRepositoryMock) GetByDeviceID(ctx context.Context, deviceID string, tenants []string) (models.Device, error) {
	if mock.GetByDeviceIDFunc == nil {
		panic("DeviceRepositoryMock.GetByDeviceIDFunc: method is nil but DeviceRepository.GetByDeviceID was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
		Tenants  []string
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
		Tenants:  tenants,
	}
	mock.lockGetByDeviceID.Lock()
	mock.calls.GetByDeviceID = append(mock.calls.GetByDeviceID, callInfo)
	mock.lockGetByDeviceID.Unlock()
	return mock.GetByDeviceIDFunc(ctx, deviceID, tenants)
}

// GetByDeviceIDCalls gets all the calls that were made to GetByDeviceID.
// Check the length with:
//     len(mockedDeviceRepository.GetByDeviceIDCalls())
func (mock *DeviceRepositoryMock) GetByDeviceIDCalls() []struct {
	Ctx      context.Context
	DeviceID string
	Tenants  []string
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
		Tenants  []string
	}
	mock.lockGetByDeviceID.RLock()
	calls = mock.calls.GetByDeviceID
	mock.lockGetByDeviceID.RUnlock()
	return calls
}

// GetBySensorID calls GetBySensorIDFunc.
func (mock *DeviceRepositoryMock) GetBySensorID(ctx context.Context, sensorID string, tenants []string) (models.Device, error) {
	if mock.GetBySensorIDFunc == nil {
		panic("DeviceRepositoryMock.GetBySensorIDFunc: method is nil but DeviceRepository.GetBySensorID was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		SensorID string
		Tenants  []string
	}{
		Ctx:      ctx,
		SensorID: sensorID,
		Tenants:  tenants,
	}
	mock.lockGetBySensorID.Lock()
	mock.calls.GetBySensorID = append(mock.calls.GetBySensorID, callInfo)
	mock.lockGetBySensorID.Unlock()
	return mock.GetBySensorIDFunc(ctx, sensorID, tenants)
}

// GetBySensorIDCalls gets all the calls that were made to GetBySensorID.
// Check the length with:
//     len(mockedDeviceRepository.GetBySensorIDCalls())
func (mock *DeviceRepositoryMock) GetBySensorIDCalls() []struct {
	Ctx      context.Context
	SensorID string
	Tenants  []string
} {
	var calls []struct {
		Ctx      context.Context
		SensorID string
		Tenants  []string
	}
	mock.lockGetBySensorID.RLock()
	calls = mock.calls.GetBySensorID
	mock.lockGetBySensorID.RUnlock()
	return calls
}

// GetOnlineDevices calls GetOnlineDevicesFunc.
func (mock *DeviceRepositoryMock) GetOnlineDevices(ctx context.Context, offset int, limit int, sortBy string, tenants []string) (types.Collection[models.Device], error) {
	if mock.GetOnlineDevicesFunc == nil {
		panic("DeviceRepositoryMock.GetOnlineDevicesFunc: method is nil but DeviceRepository.GetOnlineDevices was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Offset  int
		Limit   int
		SortBy  string
		Tenants []string
	}{
		Ctx:     ctx,
		Offset:  offset,
		Limit:   limit,
		SortBy:  sortBy,
		Tenants: tenants,
	}
	mock.lockGetOnlineDevices.Lock()
	mock.calls.GetOnlineDevices = append(mock.calls.GetOnlineDevices, callInfo)
	mock.lockGetOnlineDevices.Unlock()
	return mock.GetOnlineDevicesFunc(ctx, offset, limit, sortBy, tenants)
}

// GetOnlineDevicesCalls gets all the calls that were made to GetOnlineDevices.
// Check the length with:
//     len(mockedDeviceRepository.GetOnlineDevicesCalls())
func (mock *DeviceRepositoryMock) GetOnlineDevicesCalls() []struct {
	Ctx     context.Context
	Offset  int
	Limit   int
	SortBy  string
	Tenants []string
} {
	var calls []struct {
		Ctx     context.Context
		Offset  int
		Limit   int
		SortBy  string
		Tenants []string
	}
	mock.lockGetOnlineDevices.RLock()
	calls = mock.calls.GetOnlineDevices
	mock.lockGetOnlineDevices.RUnlock()
	return calls
}

// GetTenants calls GetTenantsFunc.
func (mock *DeviceRepositoryMock) GetTenants(ctx context.Context) []string {
	if mock.GetTenantsFunc == nil {
		panic("DeviceRepositoryMock.GetTenantsFunc: method is nil but DeviceRepository.GetTenants was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTenants.Lock()
	mock.calls.GetTenants = append(mock.calls.GetTenants, callInfo)
	mock.lockGetTenants.Unlock()
	return mock.GetTenantsFunc(ctx)
}

// GetTenantsCalls gets all the calls that were made to GetTenants.
// Check the length with:
//     len(mockedDeviceRepository.GetTenantsCalls())
func (mock *DeviceRepositoryMock) GetTenantsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetTenants.RLock()
	calls = mock.calls.GetTenants
	mock.lockGetTenants.RUnlock()
	return calls
}

// GetWithAlarmID calls GetWithAlarmIDFunc.
func (mock *DeviceRepositoryMock) GetWithAlarmID(ctx context.Context, alarmID string, tenants []string) (models.Device, error) {
	if mock.GetWithAlarmIDFunc == nil {
		panic("DeviceRepositoryMock.GetWithAlarmIDFunc: method is nil but DeviceRepository.GetWithAlarmID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		AlarmID string
		Tenants []string
	}{
		Ctx:     ctx,
		AlarmID: alarmID,
		Tenants: tenants,
	}
	mock.lockGetWithAlarmID.Lock()
	mock.calls.GetWithAlarmID = append(mock.calls.GetWithAlarmID, callInfo)
	mock.lockGetWithAlarmID.Unlock()
	return mock.GetWithAlarmIDFunc(ctx, alarmID, tenants)
}

// GetWithAlarmIDCalls gets all the calls that were made to GetWithAlarmID.
// Check the length with:
//     len(mockedDeviceRepository.GetWithAlarmIDCalls())
func (mock *DeviceRepositoryMock) GetWithAlarmIDCalls() []struct {
	Ctx     context.Context
	AlarmID string
	Tenants []string
} {
	var calls []struct {
		Ctx     context.Context
		AlarmID string
		Tenants []string
	}
	mock.lockGetWithAlarmID.RLock()
	calls = mock.calls.GetWithAlarmID
	mock.lockGetWithAlarmID.RUnlock()
	return calls
}

// GetWithinBounds calls GetWithinBoundsFunc.
func (mock *DeviceRepositoryMock) GetWithinBounds(ctx context.Context, bounds types.Bounds) (types.Collection[models.Device], error) {
	if mock.GetWithinBoundsFunc == nil {
		panic("DeviceRepositoryMock.GetWithinBoundsFunc: method is nil but DeviceRepository.GetWithinBounds was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Bounds types.Bounds
	}{
		Ctx:    ctx,
		Bounds: bounds,
	}
	mock.lockGetWithinBounds.Lock()
	mock.calls.GetWithinBounds = append(mock.calls.GetWithinBounds, callInfo)
	mock.lockGetWithinBounds.Unlock()
	return mock.GetWithinBoundsFunc(ctx, bounds)
}

// GetWithinBoundsCalls gets all the calls that were made to GetWithinBounds.
// Check the length with:
//     len(mockedDeviceRepository.GetWithinBoundsCalls())
func (mock *DeviceRepositoryMock) GetWithinBoundsCalls() []struct {
	Ctx    context.Context
	Bounds types.Bounds
} {
	var calls []struct {
		Ctx    context.Context
		Bounds types.Bounds
	}
	mock.lockGetWithinBounds.RLock()
	calls = mock.calls.GetWithinBounds
	mock.lockGetWithinBounds.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *DeviceRepositoryMock) Save(ctx context.Context, device models.Device) error {
	if mock.SaveFunc == nil {
		panic("DeviceRepositoryMock.SaveFunc: method is nil but DeviceRepository.Save was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Device models.Device
	}{
		Ctx:    ctx,
		Device: device,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, device)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//     len(mockedDeviceRepository.SaveCalls())
func (mock *DeviceRepositoryMock) SaveCalls() []struct {
	Ctx    context.Context
	Device models.Device
} {
	var calls []struct {
		Ctx    context.Context
		Device models.Device
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// UpdateState calls UpdateStateFunc.
func (mock *DeviceRepositoryMock) UpdateState(ctx context.Context, deviceID string, tenant string, deviceState models.DeviceState) error {
	if mock.UpdateStateFunc == nil {
		panic("DeviceRepositoryMock.UpdateStateFunc: method is nil but DeviceRepository.UpdateState was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		DeviceID    string
		Tenant      string
		DeviceState models.DeviceState
	}{
		Ctx:         ctx,
		DeviceID:    deviceID,
		Tenant:      tenant,
		DeviceState: deviceState,
	}
	mock.lockUpdateState.Lock()
	mock.calls.UpdateState = append(mock.calls.UpdateState, callInfo)
	mock.lockUpdateState.Unlock()
	return mock.UpdateStateFunc(ctx, deviceID, tenant, deviceState)
}

// UpdateStateCalls gets all the calls that were made to UpdateState.
// Check the length with:
//     len(mockedDeviceRepository.UpdateStateCalls())
func (mock *DeviceRepositoryMock) UpdateStateCalls() []struct {
	Ctx         context.Context
	DeviceID    string
	Tenant      string
	DeviceState models.DeviceState
} {
	var calls []struct {
		Ctx         context.Context
		DeviceID    string
		Tenant      string
		DeviceState models.DeviceState
	}
	mock.lockUpdateState.RLock()
	calls = mock.calls.UpdateState
	mock.lockUpdateState.RUnlock()
	return calls
}

// UpdateStatus calls UpdateStatusFunc.
func (mock *DeviceRepositoryMock) UpdateStatus(ctx context.Context, deviceID string, tenant string, deviceStatus models.DeviceStatus) error {
	if mock.UpdateStatusFunc == nil {
		panic("DeviceRepositoryMock.UpdateStatusFunc: method is nil but DeviceRepository.UpdateStatus was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		DeviceID     string
		Tenant       string
		DeviceStatus models.DeviceStatus
	}{
		Ctx:          ctx,
		DeviceID:     deviceID,
		Tenant:       tenant,
		DeviceStatus: deviceStatus,
	}
	mock.lockUpdateStatus.Lock()
	mock.calls.UpdateStatus = append(mock.calls.UpdateStatus, callInfo)
	mock.lockUpdateStatus.Unlock()
	return mock.UpdateStatusFunc(ctx, deviceID, tenant, deviceStatus)
}

// UpdateStatusCalls gets all the calls that were made to UpdateStatus.
// Check the length with:
//     len(mockedDeviceRepository.UpdateStatusCalls())
func (mock *DeviceRepositoryMock) UpdateStatusCalls() []struct {
	Ctx          context.Context
	DeviceID     string
	Tenant       string
	DeviceStatus models.DeviceStatus
} {
	var calls []struct {
		Ctx          context.Context
		DeviceID     string
		Tenant       string
		DeviceStatus models.DeviceStatus
	}
	mock.lockUpdateStatus.RLock()
	calls = mock.calls.UpdateStatus
	mock.lockUpdateStatus.RUnlock()
	return calls
}
